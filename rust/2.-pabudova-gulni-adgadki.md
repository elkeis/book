# 2. Пабудова Гульні ў Адгадкі

Давайце пагрузімся ў Раст праз прапрацоўку практычнага праэкту разам! Гэта частка пазнаёміць вас з некалькімі агульнымі задумкамі ў Раст на практыцы. Мы будзем выкарыстоўваць `let`, `match`, мэтады, звязанныя функцыі, знешнія скрыні, ды больш! У наступных частках, мы будзем даследаваць гэтыя ідэі больш дэталёва.

Мы будзем ажыццяўляць классічную праграмавальную праблему: гульня ў адгадкі. Воць як яна працуе: праграма стварыць для нас выпадковы натуральны нумар паміж 1 ды 100. Потым праграма запытае гульца ўвесці сваю здагадку. Пасля таго як здагадка ўведзена, праграма адлюструе ці  мяркаваны нумар занадта нізкі або высокі адносна загаданага. Калі здагадка карэктная, гульня надрукуе на экрану віншаванне ды скончыць выкананне.&#x20;

### Наладжванне Новага Праэкту

Каб настроіць новы праэкт, перайдзіце ў дэрыкторыю праэктаў яку вы стварылі ў [#stvarenne-deryktoryi-praektu](1/1.2-pryvitanne-mir.md#stvarenne-deryktoryi-praektu "mention"), ды зрабіце новы праэкт выкарыстоўвая Карго, наступным, ужо знаёмым нам, чынам:&#x20;

```bash
$ cargo new guessing_game
$ cd guessing_game
```

Першая каманда, `cargo new`, прынімае назву праэкта (`guessing_game`) як першы аргумент. Наступная каманда змяняе цякучую актыўную папку ў вашай абалонцы на дэрыкторыю нашага новага праэкту.&#x20;

&#x20;Азірніце толькі што створаны _Cargo.toml_ файл:

{% code title="Cargo.toml" %}
```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```
{% endcode %}

Як вы ўжо бачылі ў [#stvarenne-praektu-razam-z-kargo](1/1.3-pryvitanne-pagruzchyk.md#stvarenne-praektu-razam-z-kargo "mention"), `cargo new` стварае ангельскі аналаг праграмы "Прывітанне, мір!" дзеля вас. Аглядзіце _src/main.rs_ файл:&#x20;

{% code title="src/main.rs" %}
```rust
fn main() {
    println!("Hello, world!");
}
```
{% endcode %}

Зараз, прапануем вам скампіляваць гэтую "Hello, world!" праграму ды выкацаць яе на камп'ютары аднім крокам выкарыстоўвая каманду `cargo run`:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
```

Каманда `run` вельмі зручная, калі вам патрабова хутка паўзаемадзейнічаць з праэктам, так сама як мы будзем рабіць з нашай гульнёй, каб хутка праверыць кожную колу да таго як рухацца да наступнай.&#x20;

Адкрыйце _src/main.rs_ файл. Вам належыць пісаць код у гэтым файле.

### Апрацоўка Здагадкі

Першая частка нашай гульні ў здагадкі - гэта запыт да ўводу дадзенных ад карыстальніка праграмы, гульца. Каб першая частка выканалася дакладна правільна, нам патрэбна перш-наперш апрацаваць увядзёныя дадзеныя ды пераканацца ў тым, што яны даведзены да праграмы ў чаканым выразе. Каб пачаць, мы пазваляем гульцу ўвесці здагадку. Перамясціце, падрабязна прачытаўшы, або надрукуйце самі код з Лістынгу 2-1 у _src/main.rs_.

#### Лістынг 2-1: Код які атрымлівае здагадку ад карыстальца ды выдае яе ў друк.

{% code title="src/main.rs" %}
```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
{% endcode %}

Гэты код захоўвае шмат дадзеных, таму давайце разгледзім яго радок за радком. Каб палучыць дадзеныя ад карыстальца, а потым перадаць вынік іх апрацоўкі ў друк, мы будзем ужываць `io` бібліятэцу ўвода/вывада, дзеля гэтага нам патрабова неяк дадаць гэтую бібліятэцу ў прастору выканання коду. `io`-біліятэца - гэта частка больш вялізнай бібліятэцы `std`:&#x20;

```rust
use std::io;
```

Па змаўчанні, Раст мае мноства элементаў аб'яўленых у стандартнай бібліятэцы якія ўжо даданы ў прастору выканання кожнай праграмы. Гэтае мноства клічуць _прэлюдыей_, вы можаце пазнаёміцца з ведамі аб рэчах змешчаных ў ёй [у дакументацыі да стандартнай бібліятэкі](https://doc.rust-lang.org/stable/std/prelude/index.html).&#x20;

Калі патрэбны нам тып не знаходзіцца ў _прэлюдыі_, дызайн языка раст вымушае нас прыўносіць такія тыпы ў прастору выканання нашага коду відавочна, праз ужыванне выраза з ключавым словам `use`.  Дадавая `std:io` бібліятэцу, мы атрымліваем цэлае мноства спрыяльных функцый у абсягу нашага коду. Уключаючы такую, як здольнасць прынімаць дадзеныя ад карыстальніка праз тэкставы інтарфэйс.&#x20;

Як вы маглі бачыць у [#anatomiya-pragramy-rast](1/1.2-pryvitanne-mir.md#anatomiya-pragramy-rast "mention"), функцыя `main` - гэта пункт пачатку выканання праграмы:&#x20;

```rust
fn main() {
```

Выраз `fn` існуе каб аб'явіць у прасторы выканання нашага коду новую функцыю; пустыя дужкі, `()`,  падказваюць нам, чытачам, што функцыя не чакае ніякіх параметраў дзеля пачатку свайго выканання; А фігурная, кучаравая дужца `{`,  дае нам зразумець, што цела функцыі пачынаецца менавіта вось-вось, зараз пасля яе.&#x20;

&#x20;

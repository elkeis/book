# 2. Пабудова Гульні ў Адгадкі

Давайце пагрузімся ў Раст праз прапрацоўку практычнага праэкту разам! Гэта
частка пазнаёміць вас з некалькімі агульнымі задумкамі ў Раст на практыцы. Мы
будзем выкарыстоўваць `let`, `match`, мэтады, звязанныя функцыі, знешнія скрыні,
ды больш! У наступных частках, мы будзем даследаваць гэтыя ідэі больш дэталёва.

Мы будзем ажыццяўляць классічную праграмавальную праблему: гульня ў адгадкі.
Воcь як яна працуе: праграма стварыць для нас выпадковы натуральны нумар паміж 1
ды 100. Потым праграма запытае гульца ўвесці сваю здагадку. Пасля таго як
здагадка ўведзена, праграма адлюструе ці мяркаваны нумар занадта нізкі або
высокі адносна загаданага. Калі здагадка карэктная, гульня надрукуе на экрану
віншаванне ды скончыць выкананне.&#x20;

## Наладжванне Новага Праэкту

Каб настроіць новы праэкт, перайдзіце ў дэрыкторыю праэктаў яку вы стварылі ў
[#stvarenne-deryktoryi-praektu](1/1.2-pryvitanne-mir.md#stvarenne-deryktoryi-praektu
"mention"), ды зрабіце новы праэкт выкарыстоўвая Карго, наступным, ужо знаёмым
нам, чынам:&#x20;

```bash
$ cargo new guessing_game
$ cd guessing_game
```

Першая каманда, `cargo new`, прымае назву праэкта (`guessing_game`) як першы
аргумент. Наступная каманда змяняе цякучую актыўную папку ў вашай абалонцы на
дэрыкторыю нашага новага праэкту.&#x20;

&#x20;Азірніце толькі што створаны _Cargo.toml_ файл:

{% code title="Cargo.toml" %}
```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```
{% endcode %}

Як вы ўжо бачылі ў
[#stvarenne-praektu-razam-z-kargo](1/1.3-pryvitanne-pagruzchyk.md#stvarenne-praektu-razam-z-kargo
"mention"), `cargo new` стварае англіскі аналаг праграмы "Прывітанне, мір!"
дзеля вас. Аглядзіце _src/main.rs_ файл:&#x20;

{% code title="src/main.rs" %}
```rust
fn main() {
    println!("Hello, world!");
}
```
{% endcode %}

Зараз, прапануем вам скампіляваць гэтую "Hello, world!" праграму ды выкацаць яе
на камп'ютары аднім крокам выкарыстоўвая каманду `cargo run`:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
```

Каманда `run` вельмі зручная, калі вам патрабова хутка паўзаемадзейнічаць з
праэктам, так сама як мы будзем рабіць з нашай гульнёй, каб хутка праверыць
кожную колу да таго як рухацца да наступнай.&#x20;

Адкрыйце _src/main.rs_ файл. Вам належыць пісаць код у гэтым файле.

## Апрацоўка Здагадкі

Першая частка нашай гульні ў здагадкі - гэта запыт да ўводу дадзенных ад
карыстальніка праграмы, гульца. Каб першая частка выканалася дакладна правільна,
нам патрэбна перш-наперш апрацаваць увядзёныя дадзеныя ды пераканацца ў тым, што
яны даведзены да праграмы ў чаканым выразе. Каб пачаць, мы пазваляем гульцу
ўвесці здагадку. Перамясціце, падрабязна прачытаўшы, або надрукуйце самі код з
Лістынгу 2-1 у _src/main.rs_.

#### Лістынг 2-1: Код які атрымлівае здагадку ад карыстальца ды выдае яе ў друк.

{% code title="src/main.rs" %}
```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
{% endcode %}

Гэты код захоўвае шмат дадзеных, таму давайце разгледзім яго радок за радком.
Каб палучыць дадзеныя ад карыстальца, а потым перадаць вынік іх апрацоўкі ў
друк, мы будзем ужываць `io` бібліятэцу ўвода/вывада, дзеля гэтага нам патрабова
неяк дадаць гэтую бібліятэцу ў прастору выканання коду. `io`-біліятэца - гэта
частка больш вялізнай бібліятэцы `std`:&#x20;

```rust
use std::io;
```

Па змаўчанні, Раст мае мноства элементаў аб'яўленых у стандартнай бібліятэцы
якія ўжо даданы ў прастору выканання кожнай праграмы. Гэтае мноства клічуць
_прэлюдыей_, вы можаце пазнаёміцца з ведамі аб рэчах змешчаных ў ёй [у
дакументацыі да стандартнай
бібліятэкі](https://doc.rust-lang.org/stable/std/prelude/index.html).&#x20;

Калі патрэбны нам тып не знаходзіцца ў _прэлюдыі_, дызайн языка раст вымушае нас
прыўносіць такія тыпы ў прастору выканання нашага коду відавочна, праз ужыванне
выраза з ключавым словам `use`. Дадавая `std:io` бібліятэцу, мы атрымліваем
цэлае мноства спрыяльных функцый у абсягу нашага коду. Уключаючы такую, як
здольнасць прынімаць дадзеныя ад карыстальніка праз тэкставы інтарфэйс.&#x20;

Як вы маглі бачыць у
[#anatomiya-pragramy-rast](1/1.2-pryvitanne-mir.md#anatomiya-pragramy-rast
"mention"), функцыя `main` - гэта пункт пачатку выканання праграмы:&#x20;

```rust
fn main() {
```

Выраз `fn` існуе каб аб'явіць у прасторы выканання нашага коду новую функцыю;
пустыя дужкі, `()`, падказваюць нам, чытачам, што функцыя не чакае ніякіх
параметраў дзеля пачатку свайго выканання; А фігурная, кучаравая дужца `{`, дае
нам зразумець, што цела функцыі пачынаецца менавіта вось-вось, зараз пасля
яе.&#x20;

Як мы так сама вывучылі ў
[#anatomiya-pragramy-rast](1/1.2-pryvitanne-mir.md#anatomiya-pragramy-rast
"mention"), `println!` - гэта макрас які друкуе страку на экран карыстальніка:

```rust
    println!("Guess the number!");

    println!("Please input your guess.");
```

&#x20;Гэты код пячатае назву гульні ды запыт да дзеяння дзеля
карыстальніка.&#x20;

### Захоўванне Значэнняў у Пераменных

Наступным чынам, стварым пераменную каб захаваць дадзеныя ад карыстальніка:

```rust
    let mut guess = String::new();
```

Наша праграма пачынае рабіцца цікавай! У гэтым невялічкім радку здейсняецца шмат
чаго заслугоўваючага нашу павагу. Мы ўжываем выраз `let` каб стварыць
пераменную. Вось іншы прыклад:&#x20;

```rust
let apples = 5;
```

Дадзены радок стварае новую пераменную `apples` ды прызначае ёй значэнне 5. У
Раст, пераменныя звычайна нельга змяніць, такім чынам, калі мы надалі пераменнай
неякае значэнне, гэтае значэнне ніколі не зменіцца. Мы разглядзім гэтае паняцце
больш падрабязна ў
частцы[3.1-peramennyya-dy-zmyanyalnasc.md](3/3.1-peramennyya-dy-zmyanyalnasc.md
"mention"). Каб зрабіць пераменную змяняльнай, нам належыць дадаць ключавое
слова `mut` перад імём пераменнай:&#x20;

```rust
let apples = 5; // не змяняльная
let mut bananas = 5; // змяняльная
```

{% hint style="info" %} Нататка: сінтаксіс `//` пазначае каментар які будзе
працягвацца да заканчэння радка. Раст ігнаруе ўсё ужытае ў каментарыях. Мы
абмяркуем каментарыі больш дэталёва ў [Часцы 3](broken-reference).&#x20; {%
endhint %}

Вернемся да праграмы "гульня ў адгадкі": зараз вы ведаеце, што `let mut guess`
аб'яўляюць змяняльную пераменную з імём `guess`. Знак раўно (`=`) паведамляе
кампілятару Раст, аб тым што нам патрэбна зараз прызначыць нешта да пераменнай.
Насупраць, справа ад знака параўнання значэнне, якое мы жадаем прывязаць да
пераменнай `guess`, рэзультат выканання `String::new`, функцыі якая вяртае новы
экзампляр `String`.
[`String`](https://doc.rust-lang.org/stable/std/string/struct.String.html) -
гэта тып які прадастаўляецца звычайнай бібліятэцай, радок які можна вырошчваць
ды UTF-8 закадаваны фрагмент тэксту.&#x20;

Сінтаксіс `::` у выразе `::new` пазначае што `new` - гэта імя звязанай з тыпам
`String` функцыі. Звязаная функцыя - гэта функцыя якая рэалізавана дзеля тыпу, у
нашым выпадку `String`. Гэтая `new` функцыя стварае новую, пустую страку. Вы
знойдзеце функцыю звязяную `new` са шматлікімі тыпамі, бо гэта звычайна імя
функцыі якая стварае новае значэнне пэўнага тыпу дадзеных.&#x20;

Цалкам `let mut guess = String::new();` - гэта выраз які стварае змяняльную
пераменную якая спасылаецца на новую, пустую істоту тыпу `String`.

### Атрыманне Дадзеных ад Карыстальніка

Успаміная тое, што мы дадалі ў прастор выканання функцыянальнасць ўвода/вывада
са стандартнай бібліятэцы праз ужыванне `use std::io;` у першым радку нашай
праграмы; давайце паспрабуем выканаць функцыю `stdin` з модулю `io`, якая
дазваляе нам апрацоўваць дадзеныя ад карыстальніка.&#x20;

```rust
    io::stdin()
        .read_line(&mut guess)
```

Калі б мы не імпартавалі модуль `io` ужывая `use std::io;` у пачатку праграмы,
мы так сама маглі б ўжываць нашу функцыю, але выкарыстоўвая больш разгорнуты
запіс: `std::io::stdin`. Функцыя `stdin` звяртае істоту тыпа
[`std::io::Stdin`](https://doc.rust-lang.org/stable/std/io/struct.Stdin.html),
які ўяуляе сабой апрацоўшчык для стандартнага інтарфэйса ўводу дзеля тэрмінала
карыстальніка.&#x20;

Наступным чынам, радок `.read_line(&mut guess)` выклікае метад
[`read_line`](https://doc.rust-lang.org/stable/std/io/struct.Stdin.html#method.read\_line)
апрацоўшчыка стандартнага інтарфэйсу, каб атрымаць дадзеныя ад карыстальніка. Мы
так сама перадаем `&mut guess` як аргумент да `read_line`, каб казаць у якую
істоту радка неабходна захаваць дадзеныя, здагадку ад гульца. Поўная праца
`read_line` заключана ў тым каб атрымаць усё тое, што карыстальнік надрукуе ў
сваім стандартным інтэрфэйсе ўвода, ды прымацаваць гэты тэкст да нашай дынамічна
пашыраючыся істоты радку (не перазапісываючы тыя дадзеныя, якія істота ўжо
трымае), пагэтуль мы перадаем спасылку на гэтую істоту ў выглядзе аргументу.
Дзеля таго каб метад `read_line` маў магчымасць змяняць значэнне радку,
патрабова каб аргумент `guess` быў аб'яўлен як змяняльная пераменная.

Знак `&` пазначае што наш аргумент - гэта _спасылка_, што дазваляе нам будаваць
праграму так, каб мноства яе частак малі магчымасць працаваць з адной ды той жа
істотай або кавалкам інфармацыі, не капіруя дадзеныя у памяці мноства разоў.
Спасылкі складаная асабліваць, але ж адна вялізных пераваг у Расце - гэта тое,
як бяспечна ды легка можна выкарыстоўваць спасылкі. Нам не патрэбна зараз ведаць
мноства дэталяў аб гэтым механізме каб скончыць праграму. На дадзеным этапе ўсё
што вам неабходна ведаць, што так сама як пераменныя, спасылкі звычайна не
змяняльны. Такім чынам вам патрабова пісаць `&mut guess` замест `&guess` каб
зрабіць істоту па спасыльцы змяняльнай. (У Частцы 4 мы разгледзім спасылкі больш
падрабязна.)

### Апрацоўка Патэнцыйных Памылак разам з `Result`&#x20;

Мы ячшэ працуем над адзіным выразам. Зараз мы пазнаёмімся са значэннем трэцяга
радку тэксту ў нашым выразе:

```rust
        .expect("Failed to read line");
```

Мы маглі бы запісаць наш выраз як:

```rust
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

Аднак, адзіны працяжны радок чытаць складана, такім чынам значна лепш падзяліць
яго. Мудрым вырашэннем будзе перанесці на новы радок запыт на выкананне
наступнага метада, які запісываецца ужываючы `.method_name()` сінтаксіс. Давайце
даведаемся, што гэты новы радок робіць.

Як згадвалася раней, метад `read_line` дадае ўсё, што карыстальнік уводзіць у
свой тэрмінал да істоты радку, якую мы перадаем, але наш метад таксама вяртае
нам `Result` значэнне.
[`Result`](https://doc.rust-lang.org/stable/std/result/enum.Result.html) - гэта
[_пералік_](https://doc.rust-lang.org/stable/book/ch06-00-enums.html), які
звычайна мае назву _enum_, ён так сама з'яўляецца тыпам які мае адзін з мноства
магчымых станаў. Мы называем кожны магчымы стан _варыянтам._

Варыянт тыпу `Result` можа быць `Ok` або `Err`. Варыянт `Ok` пазначае, што
выкананне аперацыі было паспяховым, а ўнутры `Ok` знаходзіцца паспяхова
створанае значэнне. Варыянт `Err` пазначае, што выкананне не атрымалася, а `Err`
змяшчае дадзеные аб тым як ці чаму здарыўся збой.&#x20;

Значэнні тыпа `Result` так сама як значэнні любога тыпу маюць метады вызначыные
дзеля іх істот. Экзампляр тыпу `Result` змяшчае
[`expect`](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.expect)
метад які мы можам выканаць. Калі наша істота `Result` маець значэнне `Err`,
выкананне `expect` вымусіць праграму пацярпець крах ды адлюстраваць пасланне,
якое вы перадалі як аргумент дзеля цякучага метада. Калі пры выкананні
`read_line` метад вяртае `Err`, верагодна мы сустрэнемся з вынікам памылкі
аперацыйнай сістэмы. Калі ж істота `Result` - гэта `Ok` , `expect` возьме
зваротнаяе значэнне якое змяшчае ў сябе `Ok` ды верне менавіта яго, такім чынам
мы будзем маць магчымасць яго ўжываць далей. У нашым выпадку такое значэнне -
гэта колькасць байтаў, якія карыстальнік перадаў у нашу праграму.&#x20;

Калі вы не пажадаеце заклікаць выкананне `expect`, праграма скампілюецца, але вы
ўбачыце у сваёй абалонцы папярэджанне:&#x20;

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s

```

Раст папярэджвае вас аб тым, што вы не выкарысталі значэнне з тыпам `Result` ,
якое вяртаецца пасля выканання `read_line`, з указаннем на тое, што наша
праграма ніяк не апрацоўвае верагодную памылку.&#x20;

Каб добрым чынам пазбавіцца ад такога папярэджання, трэба дадаць код
апрацоўваючыйчы памылкі пры выкананні метада `read_line` , але ў нашым выпадку
нам дастаткова проста скончыць выкананне праграмы з памылкай, калі такая
адбудзецца, пагэтуль мы ўжываем `expect` . Мы пазнаёмімся cа здаровай тэхнікай
апрацоўкі памылак у Частцы 9.&#x20;

### Друкаванне Значэнняў Ужываючы Запаўняльнікі `println!`

За выключэннем закрываючай кучаравай дужкі, існуе толькі адзін выраз які мы яшчэ
не разгледзілі:&#x20;

```rust
println!("You guessed: {}", guess);
```

Гэты выраз друкуе наш тэкст, які зараз змяшчае дадзеныя ад карыстальніка,
здагадку. Пара фігурных дужак `{}` - гэта запаўняльнік: вы можаце ўяўляць сябе
`{}` як невялічкія крабавыя шчыпцы, якія трымаюць значэнне ў гэтым месцы. Калі
мы плануем надрукаваць значэнне пераменнай, яе імя можа быць ужыта паміж
фігурнымі дужкамі. Калі мы друкуем вынік ацэнкі выраза, мы дадаем пустыя
фігурныя дужкі ў радок фарматавання, потым працягваем наш выраз пасля радку
фарматаванне пералікам выразаў дзеля кожнай пары пустых фігурных дужак, праз
коску, у адпаведнай паслядоўнасці. Друкаванее пераменнай разам з вынікам
выканання выразу праз адзіны выклік `println!` выглядае так:&#x20;

```rust
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

Гэты код надрукуе `x = 5 and y + 2 = 12`.

### Праверка першай частцы

Давайце пераканаемся, што наша першая частка гульні працуе. Выканаем гэта праз
`cargo run` :

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

На гэтым кроку, першая частка гульні скончана: мы перадалі дадзеныя праз
клавіятуру, а потым надрукавалі іх.

## Спараджэнне сакрэтнага нумара

У гэтай частцы нам належыць парадзіць сакрэтны нумар, тый самы, які наш
карыстальнік будзе спрабаваць адгадаць. Каб гуляць было можна мноства разоў,
патрабова каб сакрэтны нумар быў розны дзеля кожнага пуску праграмы. Мы будзем
ствараць выпадковы нумар у дыяпазоне паміж 1 ды 100, каб гульня не была вельмі
складаная. Раст яшчэ не маець функцыянальнаясь стварэння выпадковых нумароў у
стандартнай бібліятэцы. Аднак, каманда Раст прапануе выкарыстоўваць [скрыню
`rand`](https://crates.io/crates/rand) з названай функцыянальнасцю.&#x20;

### Ужыванне Скрыні каб Атрымаць Больш Магчымасцяў

Помніце што скрыня - гэта калекцыя файлаў з ісходным кодам Раст. Праэкт які мы
будуем - гэта бінарная скрыня, якая можа быць выканана. Скрыня `rand` - гэта
_бібліятэчная скрыня_, якая змяшчае код які прызначаны для выкарыстання ў іншных
праграмах ды не можа быць выкананы сам па сябе.&#x20;

Каардынацыя знешніх скрыняў - гэтая тая вобласць у якой Карго-Пагрузчык сапраўды
ззяе. Перад тым як напісаць код які выкарыстоўвае `rand` бібліятэцу, нам
патрабова змяніць файл _Cargo.toml_ каб уключыць скрыню `rand` у залежнасці.
Адкрыйце гэты файл зараз ды дадайце наступныя радкі ў канец, адразу пад
загалоўкам падзелу `[dependencies]`, які ўжо створаны Пагрузчыкам аўтаматычна.
Упэўніціся што вы дадалі `rand` менавіта так сама як мы адлюстроўваем тут, разам
з нумарам версіі, або прыклады коду ў цякучай частцы нашага падручніка могуць не
адпрацаваць.&#x20;

{% code title="Cargo.toml" %}
```toml
[dependencies]
rand = "0.8.5"
```
{% endcode %}

У файлы Cargo.toml, усялякі радок які ідзе пасля загалоўка падзелу - гэта частка
падзелу. Падзел будзе працягвацца пакуль наступная секцыя не пачнецаа, адзначае
свой пачатак сваім загалоўкам. У `[dependencies]` вы апавяшчаеце Пагрузчык, ад
якіх знешніх скрыняў залежыць ваш праект ды якія іх версіі вам неабходны. У
дадзеным выпадку мы пазначаем што нам патрабова скрыня `rand` з яе
спецыфікатарам семантычнага версіяніравання `0.8.5` . Карго разумее [Семантычнае
Весіяніраванне](http://semver.org/) (часам маючым імя _SemVer_), якое з'яўляецца
стандартам запісвання нумароў версій. Пэўны спецыфікатар `0.8.5` па сутнасці
скарачаны варыянт дзе ля `^0.8.5`, які маець на ўвазе абы якую версію, што
прынамсі 0.8.5 але менш за 0.9.0.

Пагрузчык разлічвае, што гэтыя версіі вышэй будуць маць публічныя IПА
сумяшчальныя з версіяй 0.8.5, так сама такая спецыфікацыя гарантуе што вы
атрымаеце дзе ля свайго коду апошні патч-рэліз які па-ранейшаму будзе
кампілявацца разам з кодам у гэтай частцы. Любая версія 0.9.0 або больш не
гарантуе каб вы малі такія ж самыя ІПА якія выкарыставаны ў наступным
прыкладзе.&#x20;

Зараз, не змяняючы нічога ў кодзе, давайце скампілюем праэкт, як паказвае
Лістынг 2-2.&#x20;

#### Лістынг 2-2: Вынік ад выканання `cargo build` пасля дадання скрыні rand як залежнасці

```bash
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s

```

Вы можаце бачыць адрозніваючыся нумар версіі (але ён будзе сумяшчальны з кодам,
дзякуючы SemVer!) так сама радкі могуць адрознівацца (залежыць ад аперацыйнай
сістэмы), а яшчэ радкі могуць быць у іншым парадку.&#x20;

Калі мы ўключаем знешнюю залежнасць, Пагрузчык здабывае з _рэестру_ ўсе апошніе
версіі ўсяго, што наша залежнасць патрабуе атрымаць. Дадзеныя якія Пагрузчык
загружае ў сістэму - гэта копіі дадзеных якія змешчаны на сайце
[Crates.io](https://crates.io). Crates.io - гэта месца куды праграмісты Раст
запампоўваюць свае праэкты з адкрытым ісходным кодам дзе ля адзін аднаго. &#x20;

Пасля аднаўлення рэестру, Пагрузчык правярае падзел `[dependencies]` да
загруджае усялякія скрыні пералічаныя але ячшэ не спампованыя. У нашым пэўным
выпадку мы дадалі толькі `rand` як залежнасць, Пагрузчык так сама схапіў дзеля
нас астатнія скрыні ад якіх залежыць у сваю чаргу скрыня `rand`. Пасля загрузкі
скрынь, Раст кампілюе іх а потым кампілюе праэкт разам з усімі даступнымі
залежнасцямі.

Калі мынеадкладна выканаем `cargo build` не робячы ніякіх змяненняў, мы не
ўбачым ніякага вываду акрамя радку `Finished`. Пагрузчык ведае, што ён ужо
спампаваў ды скампіляваў залежнасці, а вы не змянялі нічога аб іх у _Cargo.toml
._ Карго так сама ведае што вы не зрабілі ніякіх змен у сваім кодзе, такім чынам
яму не патрэбна перакампіляваць яго так сама. Не маючы ніякай працы, ён проста
выходзіць.&#x20;

Калі вы адкрыеце _src/main.rs_ файл, каб зрабіць трывіяльныя змены, захаваеце
яго, а потым пабудуеце зноў, вы ўбачыце толькі дзва радку ў вывадзе свайго
тэрміналу:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```

Гэтыя радкі абазначаюць што Карго аднаўляе вашы пабудаваныя бінарныя файлы
толькі праз даданне або перазапіс адпаведных са зменамі ў нашым src/main.rs
файле дадзеннымі. Нашы залежнасці не змянялісь, такім чынам Карго ведае, што мае
права на перавыкарыстанне таго, што ўжо спампавана ды скампілявана раней.&#x20;

### Гарантаванне Ўзнаўляльных пабудоў з выкарыстаннем _Cargo.lock_ Файла

У Пагрузчыке ёсць механіка якая гарантуе, што можна перабудаваць такіж самы
артэфакт кожны час, калі вы ці хтосці іншы кампілюе ваш код: Карго будзе
выкарыстоўваць толькі версіі залежнасцяў вы спецыфіцыравалі пакуль вы не
вырашыце інакш. Напрыклад калі на наступным тыдні версія 0.8.6 скрыні `rand`
стане даступна, ды такая версія будзе змяшчаць важнае выпраўленне, але так сама
будзе трымаць рэгрэсіі якія ламаюць ваш код. Каб вырашыць гэтую ды падлобныя
праблемы, Раст стварае _Cargo.lock_ файл першы раз калі вы выконваеце `cargo
build`, такім чынам захоўвая гэты файл і ў нашай _guessing\_game_
дэрыкторыі.&#x20;

Калі вы будуеце праэкт першы раз, Карго вылічвае ўсе версіі залежнасцяў якія
адпавядаюць крытэрыям, а потым запісваюць іх у _Cargo.lock_ файл. Калі ў
будучыні вы вырашыце пабудаваць ваш праэкт, Пагрузчык убачыць што _Cargo.lock_
файл існуе ды выкарыстае версіі якія запісаны ў ім, замест таго каб рабіць працу
па вылічэнню версій зноў. Гэтая механіка робіць рэзультаты вашых пабудоў
узнаўляльнымі аўтаматычна. У іным выразе, ваш праэкт будзе працягваць
выкарыстоўваць версію 0.8.5 пакуль вы відавочна яе аднавіце, дзякуй _Cargo.lock_
файл. Па прычыне таго, што Cargo.lock файл паважны дзеля ўзнаўляльных пабудоў,
такі файл часта рэгіструецца ў сістэме кіравання крыніцамі дадзеных, такіх як
Git, разам з астатнім кодам у вашым праекце.&#x20;

### Аднаўленне Скрыні дзеля Атрымання Новай Версіі

Калі вы жадаеце аднавіць скрыню, Пагрузчык забяспечвае нас камандай `update`,
якая праігнаруе _Cargo.lock_ файл ды высвятліць усе апошнія версіі якія
падыходзяць да вашых спецыфікацый у _Cargo.toml_. Апасля Пагрузчык упіша тыя,
высвятленыя версіі ў _Cargo.lock_ файл. У нашым сцэнарыі, Пагрузчык будзе шукаць
толькі версіі больш за 0.8.5 ды менш за 0.9.0. Калі `rand` скрыня напрыклад
будзе аднаўлена праз выданне дзьвух новых версій 0.8.6 ды 0.9.0, вы ўбачыце
наступныя радкі, калі вы выканаеце `cargo update`:

```bash
$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -> v0.8.6
```

Карго ігнаруе рэліз 0.9.0. Так сама вы можаце прыкмеціць змену ў вашым
Cargo.lock файлу, адзначыўшы што версія `rand` скрыні якую вы зараз будзеце
выкарыстоўваць цяпер 0.8.6. Каб выкарыстаць скрыню `rand` з версіяй 0.9.0 або
іншай версіяй з серыі 0.9.x, вам будзе неабходна аднавіць _Cargo.toml_ файл
такім чынам, каб падзел з залежнасцямі выглядаў як тут: &#x20;

```toml
[dependencies]
rand = "0.9.0"
```

У наступным разе, калі вы выканаеце `cargo build`, Пагрузчык аднавіць рэестр
даступных скрынь ды перагледзе патрабаванні да скрыні `rand`саадносна да новай
версіі якую вы жадаеце замовіць з рэестру.

Мы маем шмат чаго распаведаць аб [Пагрузчыку](https://doc.rust-lang.org/cargo/)
да [яго экасістэме](https://doc.rust-lang.org/cargo/reference/publishing.html),
якую мы абмяркуем у Частцы 14, але каб працягваць гэтую частку, зараз вы ведаеце
ужо ўсё што неабходна. Карго вельмі спадручны дзеля паўторнага выкарыстання
бібліятэц, такім чынам Растацарыянцы маюць магчымасць пісаць невялічнія праэкты
якія збіраюцца з некалькі пакетаў.&#x20;

### Генерацыя Выпадковага Нумара

Давайце пачнем выкарыстоўваць `rand` каб стварыць сакрэтны нумар дзеля гульні.
Наступным крокам аднавім _src/main.rs_, як адлюстравана ў Лістынгу 2-3.

#### Лістынг 2-3: Даданне коду дзеля стварэння выпадковага нумару

{% code title="src/main.rs" %}
```rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```
{% endcode %}

Перш-наперш мы дададзім радок `use rand::Rng;`. Рыса (`trait`) `Rng` аб'яўляе
метады якія раялізуюць генератары выпадковых нумароў, гэтая рыса павінна
знаходзіцца ў абсягу нашага коду, каб мы маглі выкарыстоўваць гэтыя метады. У
Частца 10 мы разгарнем гэты канцэпт дэталёва.&#x20;

Далей, мы дададзім два радкі ў cярэдзіну. На першым радку, мы выканаем функцыю
`rand::thread_rnd` якая звярнець нам асаблівы генератар выпадковых нумароў:
генератар які з'яўляецца лакальным для цякучага выканаўчага патоку ды зароджаны
самой аперацыйнай сістэмай. Пасля мы выклікаем `gen_range` мэтад нашага
генератара выпадковых нумароў. Гэты метад аб'яўлены праз `Rng` рысу якую мы
дадалі ў прастору выканання коду ўжывая `use rand::Rng;` выраз. Метад
`gen_range` чакае дыяпазонны выраз у якасці аргументу ды стварае выпадковы нумар
у дадзеным дыяпазоне. Тып дыяпазоннага выразу які мы выкарыстоўваем маець выгляд
`start..=end` уключаючны канцы, такім чынам нам належыць ужыць запіс `1..=100`
каб запытаць нумар паміж 1 ды 100.

{% hint style="info" %} Нататка: Калі вам не будзе вядома якія рысы
выкарыстоўваць, або якія мэтады ды функцыі са скрыні выконваць, кожная скрыня
маець сваю асабістую дакументацыю разам з указаннямі як карыстацца пэўнай
скрыняй. Ячшэ адна цікавая асаблівасць Пагрузчыку - гэта магчымасць пабудаваць
ды адкрыць у браўзеры дакументацыю да ўсіх вашых залежнасцей праз каманду `cargo
doc --open` . Калі нам напрыклад будзе цікава іншая функцыянальнасць скрыні
`rand`, выканайце `cargo doc --open` ды пстрыкніце `rand` у бакавой панэлі па
левы бок.&#x20; {% endhint %}

Другі радок які мы дадалі друкуе наш сакрэтны нумар. Будзе зручна пры
распрацоўцы праграмы маць магчымасць праверыць наш нумар, але мы выдалім гэты
радок дзеля нашай фінальнай версіі. Наш праэкт не будзе вялікай гульнёй калі
праграма будзе выдаваць адказ у пачатку выканання!

&#x20;Паспрабуем выканаць праграму некалькі разоў:&#x20;

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5

```

Вам варта бачыць дзьва розных выпадковых нумары, а ім належыць быць нумарамі
паміж 1 ды 100. Выдатная праца!

## Параўнанне Здагадкі з Сакрэтным Нумарам

Зараз, калі ў нас ёсць нумар ад карыстальніка ды сакрэтны нумар, мы можам
параўнаць іх. Гэты крок адлюстрован на Лістынгу 2-4. Заўважце, што гэты код
пакуль што не скампілюецца. Мы разбярэм памылкі пакуль растлумачываем
логіку.&#x20;

#### Лістынг 2-4: Апрацоўка рэзультата параўнання дзьвух нумароў <img src=".gitbook/assets/does_not_compile.svg" alt="" data-size="line">

{% code title="src/main.rs" %}
```rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```
{% endcode %}

Першым чынам мы дададзім да прасторы выканання ячшэ адзін `use` выраз, адкрывая
дзеля карыстання тып званы `std::cmp::Ordering` са стандартнай бібліятэцы. Тып
`Ordering` - гэта яшчэ адзін пералік з варыянтамі `Less`, `Greater`, ды `Equal`.
Па сутнасці з'яўляючыся магчымымі вынікамі параўнання дзьвух значэнняў.&#x20;

Наступным чынам мы дадаем пяць радкоў у канец цела `main()` якія выкарыстоўваюць
наш тып `Orderding`. Метад `cmp` параўноўвае дзьва значэнні ды можа быць
запытаны на чым заўгодна, што можа быць параўнана. Метад чакае на ўход спасылку
на тое, што вы жадаеце параўнаць са значэннем у якім вы зацікаўлены. У дадзеным
пракладзе выкананне мэтаду параўноўвае здагадку з сакрэтным нумарам. Пасля
параўнання метад звяртае варыянт пераліку `Ordering` які мы дадалі ў абсяг праз
сцвярджэнне `use`. Мы выкарыстоўваем
[`match`](https://doc.rust-lang.org/stable/book/ch06-02-match.html) выраз каб
дадаць вырашальную логіку пра тое, што наш код будзе рабіць далей, базіруючыся
на варыянце `Ordering` які звярнуўся ў рэзультаце выканання метада `cmp`
параўноўваючага значэнні `guess` ды `secret_number`.

Выраз `match` мае мноства рук (або галін). Кожная рука складаецца з узору
(патэрну), якому будзе адпавядаць вынік пэўнага параўнання, ды коду які будзе
выклікацца калі значэнне пераданае ў `match` адпавядае ўзору на руцэ. Раст
прымае адпаведнае значэнне і па чарзе праглядае ўзор кожнай рукі. Узоры ды
супастаўляючыя канструкцыі - гэта магутныя прылады ў Раст, якія дазваляюць
выразіць мноства маршрутаў па якім пайдзе ваш патока выканання ў залежнасці ад
апрацоўваючыся дадзеных, ды гарантаваць, што ваш код можа апрацаваць іх усе.
Гэтыя асаблівасці будуць раскрыты дакладна ў Частцы 6 ды Частцы 18,
саадносна.&#x20;

Давайце прабяжымся па прыкладу з `match` выразам які мы ўжылі. Уяўвім сабе, што
карыстальнік здагадаў нумар 50, а выпадкова створаны нумар у дадзенам выпадку
38.

Калі праграма будзе параўноваць 50 да 38, метад `cmp` звярне `Ordering::Greater`
таму што нумар 50 - вялізнее за 38. Выраз `match` атрымлівае
`Orderding::Greater` значэнне, ды пачынае пачынае параўноўваць яго з узорам на
кожнай руцэ. Гледзячы ўзор першай руцы, `Ordering::Less`, ён бачыць што значэнне
`Ordering::Greater` не роўнае з `Ordering::Less`, таму праграма ігнаруе код
далучаны на гэтай руцы ды рухаецца да апрацоўцы наступнай руцы. Узор наступнай
руцы `Orderding:Greater`, які ужо адпавядае `Ordering:Greater`! Асацыіраваны код
у той руцэ будзе выконваць місію друку `Too big!` на экран карыстальніка. Выраз
`match` сканчаецца пасля першага паспяховага параўнання, такім чынам паток
вынанання не будзе рухацца да апошняй руцы ў нашым выпадку.&#x20;

Аднакш, код з
[#listyng-2-4-apraco-ka-rezultata-para-nannya-dzvukh-numaro](2.-pabudova-gulni-adgadki.md#listyng-2-4-apraco-ka-rezultata-para-nannya-dzvukh-numaro
"mention")пакуль яшчэ не зможа скампілявацца. Давайце паспрабуем:&#x20;

{% code overflow="wrap" %}
```bash
$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&String`, found `&{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&String`
              found reference `&{integer}`
note: method defined here
  --> /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cmp.rs:840:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
```
{% endcode %}

Сутнасць паведамлення аб памылке - несупадзенне тыпаў. Раст мае моцную сістэму
статычных тыпаў. Тым не менш тыпы ў Расце за конт ягонай сістэмы вываду тыпаў
могуць усплываць. Калі мы пішам `let mut guess = String::new()` , тып дзеля
`guess` вызначаецца за конт усплыцця як `String` , так што нам не патрэбна яго
дадаваць відавочна. `secret_number`, з другога боку - гэта нумарны тып. У расце
ёсць тыпы, якія могуць маць значэнне ад 1 да 100: `i32`, нумар размернасцю 32
біты; `u32`, нумар у 32 біты без знака (+/-), `i64` , 64-бітны нумар; ды іншыя.
Калі нічога іншага не вызначана, Раст па змаўчанні выкарыстоўвае тып `i32`, які
і з'яўляецца тыпам `secret_number` калі мы неяк не дадазім інфармацыю аб тыпах
дзесці, адкуль такі тып можа ўсплыць ды прызначыцца да нашай пераменнай. Прычына
памылкі ў тым, што Раст не можа параўнаць з нумарным тыпам тып `String` .

У рэшце рэшт, мы жадаем пераўтварыць `String` якую праграма вычытвае як дадзеныя
карыстальца ў нумарны тып, такім чынам мы можам параўнаць яе з сакрэтным нумарам
так сама як нумар.&#x20;

{% code title="src/main.rs" %}
```rust
    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }

```
{% endcode %}

У радку:

```rust
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

Мы стварылі пераменную з назвай `guess` . Але пачакайце, хіба праграма ўжо не
мае зменнай з імём `guess` ? Мае, але паслужліва ў Расце дазволена адцяняць
папярэднія значэнні `guess` новымі. _Адцяненне_ дазваляе нам ужываць імя `guess`
зноў, замест таго каб вымусіць нас ствараць дзьве пераменныя з непаўторнымі
назвамі, такімі як `guess_str` ды `guess` , дзеля прыкладу. Мы разгледзім гэты
прынцып больш дэталёва ў Частцы 3, але ж зараз нам добра будзе ведаць што гэта
функцыянальнасць часта выкарыстоўваецца калі мы жадаем ператварыць значэнне з
аднаго тыпу да іншага.&#x20;

Мы звязваем гэтую новую пераменную з выразам `guess.trim().parse()` . У выразе,
тым што па правую сторану ад `=` - `guess` спасылае да арыгінальнай пераменнай
`guess`, якая змяшчае дадзеныя ад карыстальніка як радок. Функцыя `trim` у
істоты `String` ліквідуе любы прабел у пачатку ды ў канцы радка, якую нам
належыць выканаць каб маць магчымасць пераўтварыць радок `String` да нумаргона
тыпу `u32`, які можа змяшчаць толькі нумарныя дадзеныя. Карыстальніку належыць
увесці нумар ды націснуць `enter` каб задаволіць `read_line` такім чынам, што ён
нешта верне да апрацоўцы. Напрыклад, калі карыстальнік пячатае `5` ды націскае
`enter` , `guess` будзе выглядаць вось так: `5\n` . `\n` - уяўляя сабой "новы
радок". (На Віндаўс, пасля націска на `enter` у радок дадаецца сімвал зварота
лафету ды сімвал новага радку, `\r\n`. ) Метад `trim` ліквідуе `\n` ды `\r\n`
так сама, застаўляя ў страцы толькі `5`.

Выкананне метада [`parse` дзеля
радкоў](https://doc.rust-lang.org/stable/std/primitive.str.html#method.parse),
канвертуе радок у іншы тып дадзеных. У прыкладзе вышэй, мы выкарыстоўваем яго
каб пераўтварыць радок у нумар. Нам належыць адзначыць Расту дакладны тып
нумару, які мы жадаем атрымаць выкарыстоўваючы запіс `let guess: u32`. Двукропье
(`:`) пасля `guess` дазваляе Раст зразумець, што мы ў гэтым пэўным месцы анатуем
тып пераменнай. Нумар `u32` тыпу які мы атрымалі бяззнакавы, 32-бітны цэлы лік.
Гэта прыстойны выбар дзеля невялічкага пазітыўнага нумара. Мы будзем
адлюстроўваць іншыя тыпы нумароў у [Частцы
3](https://doc.rust-lang.org/stable/book/ch03-02-data-types.html#integer-types).

Дадаткова, `u32` анатацыя ў нашым пракладзе праграмы ды параўнанне з
`secret_number` пазначае, што Раст прызначыць тып `u32` да `secret_number` так
сама. Такім чынам параўнанне будзе паміж двума значэннямі адзінага тыпу!&#x20;

Метад `parse` будзе працаваць толькі з сімваламі якія могуць лагічна
пераўтвавацца ў нумары ды могуць лёгка выклікаць памылкі. Калі, напрыклад, радок
трымае штосці тыпа `A👍%`, у Раста не будзе магчымасці пераўтварыць такі радок у
нумар. Па прычыне таго, што можа быць збой, метад `parse` звяртае істоту тыпа
`Result`, амаль так сама як робіць `read_line` (мы звярталі на гэта ўвагу раней
ў
[#apraco-ka-patencyinykh-pamylak-razam-z-result](2.-pabudova-gulni-adgadki.md#apraco-ka-patencyinykh-pamylak-razam-z-result
"mention")) . Мы будзем лічыць гэты `Result` такім жа чынам праз выкарыстоўванне
метада `expect` зноў. Калі `parse` звяртае `Err` варыянт `Result`, па прычыне
таго, што ён не можа стварыць нумар са стракі, заклік `expect` паламае гульню ды
надрукуе паведамленне, якое мы перададзім. Калі `parse` можа паспяхова
пераўтварыць радок у нумар, ен верне `Ok` варыянт істоты `Result`, ды `expect`
верне нумар які мы чакаем ад `Ok` істоты.&#x20;

Давайце зараз выканаем праграму:&#x20;

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Добра! Нягледзячы на ​​​​тое, што перад адгадкай былі дададзены прабелы,
праграма ўсё роўна высветліла, што карыстальнік адгадаў 76. Запусціце праграму
некалькі разоў, каб убачыць розныя паводзіны з рознымі выпадкамі: адгадайце
правільны нумар, увядзіце занадта вялікі ды занадта нізкі лік.&#x20;

Большая частка гульні зараз працуе, але карыстальнік можа зрабіць толькі адну
здагадку. Давайце зменім гэта, дадаўшы цыкл!

## Дазваленне Увода Мноства Адгадак праз Цыкл&#x20;

Ключавое слова `loop` стварае бясконцы цыкл. Мы дададзім у праграму цыкл, каб
даць карыстальнікам больш шанцаў адгадаць нумар:

{% code title="src/main.rs" %}
```rust
    // --snip--

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
```
{% endcode %}

Як бачыце, мы перамясцілі ўсё, пачынаючы з падказкі пра пачатак уводу, у цыкл.
Не забудзьцеся зрабіць водступ радкоў у цыкле на дадатковых чатыры прабелы ды
выканаць праграму зноў. Зараз праграма будзе запытваць іншую здагадку кожны раз,
што фактычна стварае новую праблему. Не здаецца, што карыстальнік можа выйсці!

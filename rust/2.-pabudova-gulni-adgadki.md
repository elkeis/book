# 2. Пабудова Гульні ў Адгадкі

Давайце пагрузімся ў Раст праз прапрацоўку практычнага праэкту разам! Гэта частка пазнаёміць вас з некалькімі агульнымі задумкамі ў Раст на практыцы. Мы будзем выкарыстоўваць `let`, `match`, мэтады, звязанныя функцыі, знешнія скрыні, ды больш! У наступных частках, мы будзем даследаваць гэтыя ідэі больш дэталёва.

Мы будзем ажыццяўляць классічную праграмавальную праблему: гульня ў адгадкі. Воць як яна працуе: праграма стварыць для нас выпадковы натуральны нумар паміж 1 ды 100. Потым праграма запытае гульца ўвесці сваю здагадку. Пасля таго як здагадка ўведзена, праграма адлюструе ці  мяркаваны нумар занадта нізкі або высокі адносна загаданага. Калі здагадка карэктная, гульня надрукуе на экрану віншаванне ды скончыць выкананне.&#x20;

## Наладжванне Новага Праэкту

Каб настроіць новы праэкт, перайдзіце ў дэрыкторыю праэктаў яку вы стварылі ў [#stvarenne-deryktoryi-praektu](1/1.2-pryvitanne-mir.md#stvarenne-deryktoryi-praektu "mention"), ды зрабіце новы праэкт выкарыстоўвая Карго, наступным, ужо знаёмым нам, чынам:&#x20;

```bash
$ cargo new guessing_game
$ cd guessing_game
```

Першая каманда, `cargo new`, прынімае назву праэкта (`guessing_game`) як першы аргумент. Наступная каманда змяняе цякучую актыўную папку ў вашай абалонцы на дэрыкторыю нашага новага праэкту.&#x20;

&#x20;Азірніце толькі што створаны _Cargo.toml_ файл:

{% code title="Cargo.toml" %}
```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```
{% endcode %}

Як вы ўжо бачылі ў [#stvarenne-praektu-razam-z-kargo](1/1.3-pryvitanne-pagruzchyk.md#stvarenne-praektu-razam-z-kargo "mention"), `cargo new` стварае ангельскі аналаг праграмы "Прывітанне, мір!" дзеля вас. Аглядзіце _src/main.rs_ файл:&#x20;

{% code title="src/main.rs" %}
```rust
fn main() {
    println!("Hello, world!");
}
```
{% endcode %}

Зараз, прапануем вам скампіляваць гэтую "Hello, world!" праграму ды выкацаць яе на камп'ютары аднім крокам выкарыстоўвая каманду `cargo run`:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
```

Каманда `run` вельмі зручная, калі вам патрабова хутка паўзаемадзейнічаць з праэктам, так сама як мы будзем рабіць з нашай гульнёй, каб хутка праверыць кожную колу да таго як рухацца да наступнай.&#x20;

Адкрыйце _src/main.rs_ файл. Вам належыць пісаць код у гэтым файле.

## Апрацоўка Здагадкі

Першая частка нашай гульні ў здагадкі - гэта запыт да ўводу дадзенных ад карыстальніка праграмы, гульца. Каб першая частка выканалася дакладна правільна, нам патрэбна перш-наперш апрацаваць увядзёныя дадзеныя ды пераканацца ў тым, што яны даведзены да праграмы ў чаканым выразе. Каб пачаць, мы пазваляем гульцу ўвесці здагадку. Перамясціце, падрабязна прачытаўшы, або надрукуйце самі код з Лістынгу 2-1 у _src/main.rs_.

#### Лістынг 2-1: Код які атрымлівае здагадку ад карыстальца ды выдае яе ў друк.

{% code title="src/main.rs" %}
```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
{% endcode %}

Гэты код захоўвае шмат дадзеных, таму давайце разгледзім яго радок за радком. Каб палучыць дадзеныя ад карыстальца, а потым перадаць вынік іх апрацоўкі ў друк, мы будзем ужываць `io` бібліятэцу ўвода/вывада, дзеля гэтага нам патрабова неяк дадаць гэтую бібліятэцу ў прастору выканання коду. `io`-біліятэца - гэта частка больш вялізнай бібліятэцы `std`:&#x20;

```rust
use std::io;
```

Па змаўчанні, Раст мае мноства элементаў аб'яўленых у стандартнай бібліятэцы якія ўжо даданы ў прастору выканання кожнай праграмы. Гэтае мноства клічуць _прэлюдыей_, вы можаце пазнаёміцца з ведамі аб рэчах змешчаных ў ёй [у дакументацыі да стандартнай бібліятэкі](https://doc.rust-lang.org/stable/std/prelude/index.html).&#x20;

Калі патрэбны нам тып не знаходзіцца ў _прэлюдыі_, дызайн языка раст вымушае нас прыўносіць такія тыпы ў прастору выканання нашага коду відавочна, праз ужыванне выраза з ключавым словам `use`.  Дадавая `std:io` бібліятэцу, мы атрымліваем цэлае мноства спрыяльных функцый у абсягу нашага коду. Уключаючы такую, як здольнасць прынімаць дадзеныя ад карыстальніка праз тэкставы інтарфэйс.&#x20;

Як вы маглі бачыць у [#anatomiya-pragramy-rast](1/1.2-pryvitanne-mir.md#anatomiya-pragramy-rast "mention"), функцыя `main` - гэта пункт пачатку выканання праграмы:&#x20;

```rust
fn main() {
```

Выраз `fn` існуе каб аб'явіць у прасторы выканання нашага коду новую функцыю; пустыя дужкі, `()`,  падказваюць нам, чытачам, што функцыя не чакае ніякіх параметраў дзеля пачатку свайго выканання; А фігурная, кучаравая дужца `{`,  дае нам зразумець, што цела функцыі пачынаецца менавіта вось-вось, зараз пасля яе.&#x20;

Як мы так сама вывучылі ў [#anatomiya-pragramy-rast](1/1.2-pryvitanne-mir.md#anatomiya-pragramy-rast "mention"), `println!` - гэта макрас які друкуе страку на экран карыстальніка:

```rust
    println!("Guess the number!");

    println!("Please input your guess.");
```

&#x20;Гэты код пячатае назву гульні ды запыт да дзеяння дзеля карыстальніка.&#x20;

### Захоўванне Значэнняў у Пераменных

Наступным чынам, стварым пераменную каб захаваць дадзеныя ад карыстальніка, наступным чынам:

```rust
    let mut guess = String::new();
```

Наша праграма пачынает станавіцца цікавай! У гэтым невялічкім радку здейсняецца шмат чаго цікавага. Мы ўжываем выраз `let` каб стварыць пераменную. Вось іншы прыклад:&#x20;

```rust
let apples = 5;
```

Гэты радок стварае новую пераменную `apples` ды прызначае ёй значэнне 5. У Раст, пераменныя звычайна нельга змяніць, такім чынам, калі мы надалі пераменнай неякае значэнне, гэтае значэнне ніколі не зменецца. Мы разглядзім гэтае паняцце больш падрабязна ў частцы[3.1-peramennyya-dy-zmyanyalnasc.md](3/3.1-peramennyya-dy-zmyanyalnasc.md "mention"). Каб зрабіць пераменную змяняльнай, нам належыць дадаць ключавое слова `mut` перад імём пераменнай:&#x20;

```rust
let apples = 5; // immutable
let mut bananas = 5; // mutable
```

{% hint style="info" %}
Нататка: сінтаксіс `//` пазначае каментар які будзе працягвацца да заканчэння радка. Раст ігнаруе ўсё ужытае ў каментарыях. Мы абмяркуем каментарыі больш дэталёва ў [Часцы 3](broken-reference).&#x20;
{% endhint %}

Звяртаючыся да праграмы "гульня ў адгадкі", зараз вы ведаеце, што `let mut guess` аб'яўляюць змяняльную пераменную з імём `guess`. Знак раўно (`=`) паведамляе кампілятару Раст, аб тым што нам патрэбна зараз празначыць нешта да пераменнай. Насупраць, справа ад знака параўнання значэнне, якое мы жадаем прывязаць да пераменнай `guess`,  рэзультат выканання `String::new`, функцыі якая вяртае новы экзампляр `String`. [`String`](https://doc.rust-lang.org/stable/std/string/struct.String.html)  - гэта тып які прадастаўляецца звычайнай бібліятэцай, радок які можна вырошчваць, UTF-8 закадаваны фрагмент тэксту.&#x20;

Сінтаксіс `::` у выразе `::new` пазначае што `new` - гэта імя звязанай з тыпам `String` функцыей. Звязаная функцыя - гэта функцыя якая рэалізавана дзеля тыпа, у нашым выпадку `String`. Гэтая `new` функцыя стварае новую, пустую страку. Вы знойдзеце функцыю звязяную `new` са шматлікімі тыпамі, бо гэта звычайна імя функцыі якая стварае новае значэнне пэўнага тыпу дадзеных.&#x20;

Цалкам, `let mut guess = String::new();` выраз стварае змяняльную пераменную якая далучана да новай, пустой істоты тыпу `String`.

### Атрыманне Дадзеных ад Карыстальніка

Нагадвая тое, што мы дадалі ў прастор выканання функцыянальнасць ўвода/вывада са стандартнай бібліятэцы праз  ужыванне `use std::io;` у першым радку нашай праграмы - давайце паспрабуем выканаць функцыю `stdin` з модулю `io`,  якая дазваляе нам апрацоўваць дадзеныя ад карыстальніка.&#x20;

```rust
    io::stdin()
        .read_line(&mut guess)
```

Калі б мы не імпартавалі модуль `io` ужывая `use std::io;` у пачатку праграмы, мы так сама маглі б яе ўжываць але выкарыстоўвая больш разгорнуты запіс: `std::io::stdin`. Функцыя `stdin` звяртае істоту тыпа [`std::io::Stdin`](https://doc.rust-lang.org/stable/std/io/struct.Stdin.html), які ўяуляе сабой апрацоўшчык для стандартнага інтарфэйса ўводу дзеля тэрмінала карыстальніка.&#x20;

Наступным чынам,  радок `.read_line(&mut guess)` выклікае метад [`read_line`](https://doc.rust-lang.org/stable/std/io/struct.Stdin.html#method.read\_line) апрацоўшчыка стандартнага інтарфэйсу каб атрымаць дадзеныя ад карыстальніка. Мы так сама перадаем `&mut guess` як аргумент да `read_line` каб казаць у якую істоту радка неабходна захаваць дадзеныя, здагадку ад гульца. Поўная праца `read_line` заключана ў тым каб атрымаць усё тое, што карыстальнік надрукуе ў свой стандартны інтэрфэйс увода ды прымацаваць гэтыя літары да нашай дынамішна пашыраючыся істоты радку (не перазапісываючы тыя дадзеныя, якія істота ўжо трымае), пагэтуль мы перадаем спасылку на гэтую істоту як аргумент. Дзеля таго каб метад `read_line` маў магчымасць змяняць значэнне радку, патрабова каб аргумент `guess` быў аб'яўлен як змяняльная пераменная.

Знак `&` пазначае што наш аргумент - гэта _спасылка_, што дазваляе нам будаваць праграму так, каб мноства яе частак малі магчымасць працаваць з адной ды той жа істотай або кавалкам інфармацыі, не капіруя дадзеныя у памяці мноства разоў. Спасылкі гэта складаная асабліваць, але ж адна вялізных пераваг у Расце - гэта тое, як бяспечна ды легка можна выкарыстоўваць спасылкі. Нам не патрэбна зараз ведаць мноства дэталяў аб гэтым механізме каб скончыць праграму. На дадзеным этапе ўсё што вам неабходна ведаць, што так сама як пераменныя, спасылкі звычайна не змяняльны. Такім чынам вам патрабова пісаць `&mut guess`  замест `&guess` каб зрабіць істоту па спасыльцы змяняльнай. (У Частцы 4 мы разгледзім спасылкі больш падрабязна.)

### Апрацоўка Патэнцыйных Памылак разам з \`Result\`&#x20;

Мы ячшэ працуем над адзіным выразам. Зараз мы пазнаёмімся са значэннем трэцяга радку тэксту ў нашым выразе:

```rust
        .expect("Failed to read line");
```

Мы маглі бы запісаць наш выраз як:

```rust
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

Аднак, адзіны працяжны радок чытаць складана, такім чынам значна лепш падзяліць яго. Часта мудрым вырашэннем будзе пераносіць на новы радок запыт на выкананне наступнага метада, які запісываецца ужываючы  `.method_name()` сінтаксіс. Зараз давайце даведаемся, што гэты новы радок робіць.

Як згадвалася раней,  `read_line` дадае ўсё што карыстальнік уводзіць у свой тэрмінал да істоты радку якую мы перадаем у метад, але ён таксама вяртае нам `Result` значэнне.  [`Result`](https://doc.rust-lang.org/stable/std/result/enum.Result.html) - гэта [_пералік_](https://doc.rust-lang.org/stable/book/ch06-00-enums.html), тыпова маючы назву _enum_, які так сама з'яўляецца тыпам у адным з мноства магчымых станаў. Мы называем кожны магчымы стан _варыянтам._

Варыянтам тыпу `Result` можа быць `Ok` або `Err`. Варыянт `Ok` пазначае, што выкананне аперацыі было паспяховым а ўнутры `Ok` знаходзіцца паспяхова створанае значэнне. Варыянт `Err` пазначае, што выкананне не атрымалася а `Err` змяшчае дадзеные аб тым як ці чаму здарыўся збой.&#x20;

Значэнні тыпа `Result` так сама як значэнні любога тыпу маюць метады вызначыные дзеля іх істот. Экзампляр тыпу `Result` змяшчае [`expect`](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.expect) метад які мы можам выканаць. Калі наша істота `Result` са значэннем `Err`, выкананне `expect` вымусіць праграму пацярпець крах ды адлюстраваць пасланне якое вы перадалі як аргумент дзеля цякучага метада. Калі выкаючыся `read_line` метад вяртае `Err`, верагодна мы сустрэнемся з вынікам памылкі аперацыйнай сістэмы. Калі ж істота `Result` - гэта `Ok` , `expect` возьме зваротнаяе значэнне якое змяшчае ў сябе `Ok` ды верне менавіта яго, такім чынам мы будзем маць магчымасць яго ўжываць далей. У нашым выпадку такое значэнне - гэта колькасць байтаў якія карыстальнік перадаў у нашу праграму.&#x20;

Калі вы не пажадаеце заклікаць выкананне `expect`, праграма скампілюецца, але вы ўбачыце у сваёй абалонцы папярэджанне:&#x20;

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s

```

Раст папярэджвае вас аб тым, што вы не выкарысталі значэнне `Result` тыпу якое вяртаецца пасля выканання `read_line` з указаннем на тое што наша праграма ніяк не апрацоўвае верагодную памылку.&#x20;

Каб добрым чынам пазбавіцца ад такога папярэджання, трэба дадаць код апрацоўваючыйчы памылкі пры выкананні метада `read_line` , але ў нашым выпадку нам дастаткова проста скончыць выкананне праграмы з памылкай, калі такая адбудзецца, пагэтуль мы ўжываем `expect` . Мы пазнаёмімся cа здаровай тэхнікай апрацоўкі памылак у Частцы 9.&#x20;

### Друкаванне Значэнняў Ужываючы Запаўняльнікі \`println!\`

За выключэннем закрываючай кучаравай дужкі, існуе толькі адзін выраз які мы яшчэ не разгледзілі:&#x20;

```rust
println!("You guessed: {}", guess);
```

Гэты выраз друкуе наш тэкст які зараз змяшчае дадзеныя ад карыстальніка, здагадку. Пара фігурных дужак `{}` - гэта запаўняльнік: вы можаце ўяўляць сябе `{}` як невялічкія крабавыя шчыпцы якія трымаюць значэнне ў гэтым месцы. Калі мы плануем надрукаваць значэнне пераменнай, яе імя можа быць ужыта паміж фігурнымі дужкамі. Калі мы друкуем вынік ацэнкі выраза, мы дадаем пустыя фігурныя дужкі ў радок фарматавання, потым працягваем наш выраз пасля радку фарматаванне пералікам выразаў дзеля кожнай пары пустых фігурных дужак, праз коску, у адпаведнай паслядоўнасці. Друкаванее пераменнай разам з вынікам выканання выразу праз адзіны выклік `println!` выглядае так:&#x20;

```rust
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

Гэты код надрукуе `x = 5 and y + 2 = 12`.

### Праверка першай частцы

Давайце пераканаемся што наша першая частка гульні працуе. Выканаем гэта праз `cargo run` :

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

На гэтым кроку, першая частка гульні скончана: мы перадалі дадзеныя праз клавіятуру, а потым надрукавалі іх.

## Спараджэнне сакрэтнага нумара


# 1.3 Прывітанне, Пагрузчык!

Карго (Пагрузчык) - гэта сістэма сборкі а таксама кіраўнік пакетаў. Большасць Растацарыянцаў ужывае гэтую прыладу каб кіраваць сваімі праектамі Раст, таму што Карго выканае шмат задач для вас, такіх як пабудова/кампіляванне вашага коду, загрузка бібліятэц ад якіх залежыць ваш праект, пабудова бібліятэц (мы клічам бібліятэцы, якія неабходны дзе ля выканання вашага коду _залежнасці._)

Найбольш простыя праграмы на Расце, напрыклад тая, якую мы напісалі з вамі ў папярэдняй частцы, не маюць ніякіх залежнасцяў. Калі нам патрэбна пабудаваць праграму "Прывітанне, мір!" разам з Карго, то наш працэс будаўніцтва будзе залежыць толькі ад тых частак Карго, якія выканаюць задачы па кампіляцыі вашага кода. Але калі вы пачнеце пісаць больш складаныя праграмы Раст, вы дададзіце залежнасці, і калі вы пачнеце праект з выкарыстоўваннем Карго, дадаваць залежнасці будзе значна лягчэй.

Паколькі пераважная частка праектаў на Расце ўжывае Карго, ў наступных частках кнігі прадугледжваецца, што вы выкарыстоўваеце Карго так сама. Карго усталюецца на вашу сістэму разам з Раст, калі вы ўжываеце афіцыйныя усталёушчыкі абмяркованыя у частцы [1.1-ustano-ka.md](1.1-ustano-ka.md "mention"). Калі вы паставілі Раст ужываючы іншыя сродкі, праверце ці існуе Карго на вашай машыне выконвае ў тэрмінале наступнае:&#x20;

```bash
$ cargo --version
```

Калі вы бачыце нумар версі - вы маеце прыладу ўсталяванай у сістэме. Калі вы бачыце паведамленне аб памылке, напрыклад `command not found`, шукайце ў дакументацыі аб вашым метадзе ўсталявання як дадаць працуючую версію Карго ў вашу сістэму асабова.&#x20;

## Стварэнне Праекту разам з Карго

Давайце стварым новы праэкт выкарыстоўваючы Карго ды паглядзім ці адрозніваецца ён ад нашага арыгінальнага "Прывітанне, мір!" праэкту. Знавігіруйцесь назад у вашу дэрыкторыю праектаў (або туды, дзе вы вырашылі захаваць ваш код). Потым на любой аперацыйнай сістэме, выканайце наступные каманды:

```bash
$ cargo new hello_cargo
$ cd hello_cargo
```

Першая каманда стварае новую папку і праект з назвай _hello\_cargo._ Мы назвалі наш праэкт _hello\_cargo_, і Карго стварыла неабходныя файлы ў аднайменнай папцы.&#x20;

Другая каманда змяняе тякучы каталаг на толькі што створаны Карго прыладай. Пералічце файлы ў новай папцы, напрыклад  камандай `ls` для Лінукс ці макАС, і вы ўбачыце што Карго стварыла два файлы і дэрыкторыю для нас: _Cargo.toml_ файл ды _src_ дэрыкторыю з _main.rs_ файлам захаваным у ёй.&#x20;

Таксама Карго ініцыялізавала свежы Git рэпазітар разам з ._gitignore_ файлам. Git файлы не будуць стварацца калі вы выканаеце `cargo new` знаходзячыся ў ужо існуючым Git сховішчы; у вас ёсць магчымасць перавызначыць гэтае павядзенне ўжывая `cargo new -- vcs=git`.

{% hint style="info" %}
Нататка: Git – гэта распаўсюджаная сістэма кіравання версіямі. Вы маеце магчымасць змяняць ход выканання `cargo new` вымушая яго выкарыстоўваць іншыя сістэмы кантроля версій або нават не выкарыстоўваць такія сістэмы навогул ужываючы `--vcs` сцяг. Выканайце каманду `cargo new --help` каб пабачыць больш опцый.&#x20;
{% endhint %}

Адкрыйце _Cargo.toml_ у вашым выбраным тэкставым рэдактары. Ён павінен выглядаць згодна з кодам на Лістынгу 1-2.&#x20;

#### Лістынг 1-2: Змест _Cargo.toml_  створанага праз выкананне \`cargo new\`

{% code title="Cargo.toml" %}
```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```
{% endcode %}

Гэты файл выкарыстоўвае [TOML](https://toml.io/) (_Tom’s Obvious, Minimal Language|Мінімальны, Відавочны Язык Тома)_ фармат - які  так сама з'яўляецца фарматам файла канфігурацыі дзе ля Карго.

Першы радок, `[package]` - гэта загаловак падзелу які пазначае, што наступныя дадзеныя наладжваюць, канфігуруюць пакет. Па меры дадання інфармацыі да гэтага файлу, мы будзем дадаваць іншыя падзелы.&#x20;

Наступныя тры радкі ўсталёуваюць інфармацыю аб пакеце якая патрэбна Карго каб скампіляваць вашу праграму: назва (name), версія (version) ды выданне (edition) Раста якое неабходна ўжываць. Мы будзем весці гаворку аб `edition` ключы ў Дадатцы Д.&#x20;

Апошні радок, `[dependencies]` - гэта пачатак падзелу ў якім мы пералічым усі залежнасці нашага праекту. У Раст, пакеты з кодам згадваюцца як скрыні (_crates)._ Нам не патрэбна дадаваць ніякіх скрыней, але мы зробім гэта ў сваім першым праекце ў Частцы 2, такім чынам мы будзем выкарыстоўваць гэты падзел пазней.&#x20;

Зараз давайце адкрыем _src/main.rs_ файл і паглядзім на яго змест.&#x20;

{% code title="src/main.rs" %}
```rust
fn main() {
    println!("Hello, world!");
}
```
{% endcode %}

Карго стварыла "Hello, world!" праграму для нас, такуюж самую якую мы стварылі з вамі ў [#listyng-1-1-pragrama-yakaya-pyachatae-pryvitanne-mir](1.2-pryvitanne-mir.md#listyng-1-1-pragrama-yakaya-pyachatae-pryvitanne-mir "mention")! Тым не менш, розніца паміж нашым праэктам ды праэктам які стварыла Карго заключана ў тым, што Карго памяшчае код у _src_ дэрыкторыю і ма так сама маем _Cargo.toml_ файл канфігурацыі ў каранёвай папцы праекту.

Карго прадугледжвае, што вашы файлы ісходнікаў будуць існаваць унутры _src_ папцы. Каранёвая дэрыкторыя праэкту існуе для файлаў канфігурацыі, README файлаў, інфармацыі па ліцэнзіі ды іншых файлаў тэхнічна слаба спалучаных да вашага кода. Карго дапамагае вам кіраваць ды арганізоўваць вашы праекты, у якіх будзе ўсё на сваіх мястах. &#x20;

Калі вы пачалі праэкт які не ўжывае Карго, як мы зрабілі з праэктам "Прывітанне, мір!", мы маем магчымасць трансфарміраваць яго ў праект які выкарыстоўвае Карго. Для гэтага трэба перамясціць увесь код у _src_ папку ды стварыць саадносны Cargo.toml файл.

## Будова ды Выкананне Праэкта на Карго

Зараз давайце паглядзім чым адрозніваецца праца з аналагам праграмы "Прывітанне, мір!" створанай с ужываннем Карго! Знаходзячыся ў вашай hello\_cargo папцы ў абалонке выклікайце наступную каманду:&#x20;

{% code overflow="wrap" %}
```bash
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```
{% endcode %}

Гэтая каманда стварае выканальны файл _target/debug/hello\_cargo_ (або _target\debug\hello\_cargo.exe_, калі вы на Віндаўс) замест таго каб  стварыць яго ў вашай цякучай папцы. Пасколькі звычайная пабудова - гэта пабудова дзеля дэбага; Карго змяшчае бінарны код у папцы з назвай _debug._ Вы можаце выклікаць выканаўчы файл наступным чынам:

```bash
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

Калі ўсе пройдзя добра, радок `Hello world!` павінен быць надрукаваны ў акне вашай абалонцы. Выклікая `cargo build` першы раз мы вымушаем Карго стварыць так сама файл _Cargo.lock_ на верхнім узроўні праэкту. У гэтым файле адсочваюцца дакладныя версіі залежнасцёу ў нашым праэкту. Наш праэкт яшчэ не мае залежнасцёу так што гэты файл трошкі пуставаты. Вам не павінна змяняць гэты файл рукамі; Карго працуе са зместам гэтага файла аўтаномна.&#x20;

Такім чынам мы толькі што пабудавалі праэкт выкарыстоўвая `cargo build` каманду ды выклікалі выканаўчы файл `./target/debug/hello_cargo`, але мы можам так сама выклікаць і `cargo run` дзеля гэтых спраў, каб скампіляваць код, а потым адразу выканаць скампіляваны ў байткод файл адной камандай:&#x20;

```bash
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Карго так сама дазваляе праводзіць праверку кода, каб гарантаваць адсутнасць памылак на кроку кампілявання, але не кампілюя праэкт, `cargo check` каманда робіць гэта для нас:&#x20;

{% code overflow="wrap" %}
```bash
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```
{% endcode %}

Чаму вы можаце не пажадаць маць выканаўчы файл? Часта, `cargo check` значна хутчэй чым `cargo build` тамушта ён прапускае крок стварэння выканаўчага файла. Калі вы бесперапынна правяраеце свой выраб, ужыванне `cargo check` паскорыць зваротную сувязь дзеля вас у канітэксце вашай працы! Такім чынам, мноства Растацарыянцаў выканаюць `cargo check` перыядычна, па меры напісання сваіх праграм, каб пераканацца што іх праэкт будзе кампілявацца. Калі мы вырашаем, што пэўны кавалак нашага коду дапісан мы выклікаем `cargo build` каб потым выканаць наш код.&#x20;

Давайце рэзюмуем што мы вывучылі пра Карго да гэтага часу:&#x20;

* Мы можам стварыць праэкт праз `cargo new`.
* Мы можам пабудаваць праэкт ужывая `cargo build`.
* Мы можам пабудаваць і выклікаць праэкт аднім крокам выкарыстоўвая `cargo run`.
* Мы можам "пабудаваць" праэкт не ствараючы выканальнага файла, каб упэўніцца ў адсутнасці памылак, выклікая `cargo check`.
* Замест забруджвання папцы з кодам рэзультатамі пабудовы праэкту, Карго хавае іх у _target/debug_ папцы.

Дадатковую перавагу ў выкарыстоўванні Карго стварае тый факт, што каманды Карго не адрозніваюцца ў залежнасці ад аперацыйнай сістэмы якую мы ўжываем дзеля працы. Такім чынам, пачынаючы адсюль, мы больш не будзем адрозніваць прыклады ды інструкцыі у залежнасці ад таго ці мы карыстуем Лінукс, макАС або Віндаўс.&#x20;

### Пабудова дзеля Выдання

Калі наш праэкт нарэшце скончаны і гатовы да выдання, мы можам выклікаць `cargo build --release` каб скампіляваць яго з аптымізацыямі. Гэтая каманда створыць нам выканаўчы файл у папцы _target/release_ замест звычайнай _target/debug._ Аптымізацыі робяць выкананне нашага Раст кода больш хуткім, але даданне аптымізацый у працэс кампіляванне падаўжае час які патрабуецца для пабудовы праекту. Пагэтуль у Карго і існуе два розных профіля: адзін хутчэйшы - для распрацоўкі коду; другі для пабудовы фінальнай праграмы якую вы плануеце перадаць карыстальніку які не жадае будаваць яе асабіста, якая будзе выканацца з найбольшай хуткасцю. Калі вы праводзіце параўнальны аналіз, бэнчмаркінг часу выканання вашага коду, упэўніціся што  выканалі `cargo build --release` а потым ужо даслядуйце ваш выканаўчы файл у _target/release._

### Карго як Канвенцыя

Дзеля простых праэктаў карыстанне Карго не дадае шмат каштоўнасці у параўнанні з ужываннем звычайнага `rustc` , але Карго дакажа сваю вартасць калі вашы праграмы стануць больш мудрагелістымі. Калі праэкт абрастае залежнасцямі ці уключае ў сябе шмат файлаў, будаваць,  ужывая Карго, такі праэкт значна лягчэй.&#x20;

Нават кажучы пра наш праэкт `hello_cargo`, а менавіта пра ягоную прастату, нельга не адзначыць тое, што нават такі просты праэкт ужо зараз выкарыстоўвае вялізную частку рэяльных прылад, якія вы напэўна будзеце выкарыстоўваць на працягу вашай кар'еры ў прафесіі моцна злучанай з праграмаваннем на Раст. Нават каб пачаць працаваць з амаль любым існуючым праэктам на Раст, вы можаце ўжываць серыю наступных каманд, каб атрымаць код праз Git, прайсці ў дэрыкторыю праэкта, і пабудаваць код:&#x20;

```bash
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

Дзеля атрымання дадатковых вед пра менавіта Карго, выкарыстоўвайце [Карго-дакументацыю](https://doc.rust-lang.org/cargo/).

## Вынік

Вы зараз ужо ідзеце на вялікі пачатак вашага Раст-падарожжа! А у гэтай частцы, вы вывучылі як:&#x20;

* Усталяваць апошнюю ўстойлівую версію Раст выкарыстоўвая `rustup`
* Аднавіць Раст да больш новай версіі.&#x20;
* Адкрыць мясцова усталяваную дакументацыю.&#x20;
* Напісалі разам з намі ды выканалі сваю першую праграму "Прывітанне, мір!" выкарыстоўвая `rustc` непасрэдна.
* Стварылі ды выканалі свежы праэкт ужывая адпаведны канвенцыям Карго прылады.&#x20;

Зараз добры час каб пабудаваць больш істотную праграму, каб трошкі звыкнуцца з напісаннем да разуменнем кода на Раст. Такім чынам у Частцы 2, мы пабудуем праграму гульні ў адгадкі. Калі вы жадаеце хутчэй пачаць разумець як працуюць асноўные канцэпцыі Раст - глядзіце адразу ў Частку 3, а потым вяртайцеся да Частцы 2. &#x20;

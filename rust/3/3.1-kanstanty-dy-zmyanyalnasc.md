# 3.1 Канстанты ды Змяняльнасць

Як згадвалася ў секцыі [#zakho-vanne-znachennya-u-peramennykh](../2.-pabudova-gulni-adgadki.md#zakho-vanne-znachennya-u-peramennykh "mention"), па змаўчанню Раст стварае _нязменныя пераменныя,_ ці, як зручней іх зваць у дадзенай кнізе, _дынамічныя канстанты (дыканстанты)_. Гэта толькі адзін з мноства штрушкоў, якімі надзяляе Раст наш код, у якім мы можам карыстацца той бяспекай ды лёгкім у рэялізацыі паралелізме якія Раст прапануе нам. Тым не менш, у нас усё яшчэ ёсць варыянт каб зрабіць нашы _дыканстанты_ ўсё ж такі _змяняльнымі_. Давайце разбярэмся як гэта зрабіць, ды чаму Раст падштрухоўвае вас аддаваць перавагу _незмяняльнасці,_ а так сама чаму час ад часу вы можаце пажадаць _змен_.&#x20;

Калі мы ўжываем _дыканстанты_, усялякі раз, калі яе значэнне прымацоўваецца да яе імя, мы боль  не можам яго перазапісаць. Каб адлюстраваць гэта, давайце стварым новы праэкт _variables_ у папцы з праектамі _projects_ выклікая каманду `cargo new variables`.&#x20;

Пасля, у вашай папцы `variables`, адкрыйце `src/main.rs` ды замяніце ягоны код наступным, які пакуль што не скампілюецца <img src="../.gitbook/assets/does_not_compile.svg" alt="" data-size="line"> :&#x20;

{% code title="src/main.rs" %}
```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
{% endcode %}

Захавайце ды выканайце файл выкарыстоувая каманду `cargo run`. Вы павінны атрымаць паведамленне аб памыльцы змяняльнасці, як адлюстрована ў наступным прыкладзе:&#x20;

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error

```

Дадзены прыклад паказвае як кампілятар дапамагае нам знайсці паімылкі ў нашых праграмах. Памылкі кампілятара могуць расчароўваць, але яны толькі гавораць нам аб тым, што ваша праграма пакуль што не робіць бяспечна тое, што вы жадаеце каб яна рабіла; такія памылкі не значаць, што вы дрэнны праграміст! Вопытныя Растацарыянцы так сама атрымліваюць памылкі пры кампіляванні.

Мы атрымалі памылку `cannot assign twice to immutable variable 'x'` таму што вы паспрабавалі прызначыць іншае значэнне да _дыканстанты_ `x`.&#x20;

Важна, каб мы атрымлівалі памылкі пры кампіляцыі калі мы спрабуем змяніць значэнне якое створана як _канстанта_, таму што гэтая пэўная сітуацыя можа прывесці да памылак. Калі адна частка нашага коду дзейнічае ісходзячы з мяркавання, што значэнне ніколі не будзе змяняцца, ды іншая частка коду змяняе гэтае значэнне, магчыма, што першая частка коду не будзе рабіць тое, дзеля чаго яна была спраяктавана. Прычыны такіх памылак можа быць складана вызначыць пастфактум, у асаблівасці калі другая частка коду змяняе значэнне толькі _час ад часу_. Кампілятар Раста гарантуе тое, што калі вы канстатуеце ў кодзе, што значэнне не будзе змяняцца — яно на самой справе не будзе змяняцца, тамушта праграма інакш не скампілюецца; такім чынам вам не патрэбна заўсёды трымаць вочы на ўсіх месцах дзе ўжываецца такое значэнне. Так сама аб нашым кодзе лягчэй разважаць пры распрацоўцы.&#x20;

Але _змяняльнасць_ можа быць вельмі карыснай, яна можа зрабіць працэс напісання коду больш зручным. Хоць _дыканстанты_ нельга змяніць па змаўчанню, мы можам пераўтварыць іх у _пераменныя_ праз даданне выраза `mut` спераду назвы _дыканстанты_, як мы рабілі ў [2.-pabudova-gulni-adgadki.md](../2.-pabudova-gulni-adgadki.md "mention"). Даданне `mut` так сама робіць відавочным наш намер дзеля будучых чытачоў нашага коду, паказваючы, што іншыя частцы коду будуць змяняць значэнне нашай _пераменнай_.  &#x20;

Напрыклад, давайце зменім `src/main.rs` наступным чынам:&#x20;

{% code title="src/main.rs" %}
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
{% endcode %}

Калі зараз мы паспрабуем выканаць праграму, мы атрымаем наступныя радкі:&#x20;

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6

```

&#x20;Нам дазваляецца змяняць значэнне якое мы прымацавалі да `x` з `5` на `6`, калі мы выкарыстоўваем `mut`. У рэшце рэшт, гэта вам вырашаць, дзе выкарыстоўваць _змяняльнасць_ або дзе не, выкарыстоўванне або не выкарыстоўванне `mut` – залежыць ад таго, што вы лічыце будзе больш выразна адлюстроўваць вашу ідэю ўвогуле.

## Канстанты

Так сама як _дыканстанты_, _канстанты_ – гэта значэнні, якія прымацоўваюцца да імя, ды не могуць быць зменены, але ёсць некалькі адрозненняў паміж _канстантамі_ ды _дынамічнымі канстантамі_.&#x20;

Па першых, вам нельга выкарыстоўваць `mut` для _канстант_.  _Канстанты_ не проста нязменныя па змаўчанню – яны заўсёды _нязменныя_. Калі вы аб'яўляеце _канстанты_ выкарыстоўвая `const` замест `let` , тып значэння _павінен_ быць адзначан.  Больш падрабязна, мы разгарнем тыпы, ды іх аб'яўленні у наступнай секцыі [3.2-typy-dadzenykh.md](../3.2-typy-dadzenykh.md "mention"), таму не хвалюйцеся пра дэталі зараз. Проста ведайце, што вы заўсёды павінны рабіць анатацыі да тыпу.

_Канстанты_ можна аб'яўляць у любой вобласці бачнасці, у тым ліку ў глабальнай, што робіць магчымым іх выкарыстанне ў якасці значэнняў якія будуць у абсягу коду ў шматлікіх месцах праграмы.

Апошняе, чым _канстанты_ адрозніваюцца ад _дыканстант_, гэта тое, што _канстантам_ можа быць прызначаны толькі вынік разліку сапраўднага _нязменнага_ выраза, а не значэнне якое будзе разлічана калісці ў ходзе выканання праграмы. Іншымі словамі звычайныя _канстанты_ статычны і разлічваюцца на этапе кампіляцыі.

Вось прыклад аб'яўлення такой _канстанты_:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

Імя _канстанты_ – `THREE_HOURS_IN_SECONDS`, а яе значэнне зададзена праз матэматычны выраз памнажэння `60` (колькасць секунд у хвіліне) на `60` (колькасць хвілін у гадзіне) на `3` (колькасць гадзін, якую мы хочам улічваць у гэтай праграме). Згодна з пагадненнем аб найменнях у Раст, для аб'яўлення _канстант_ выкарыстоўваюцца загалоўныя літары, а словы падзяляюцца знакам падкрэслівання. Кампілятар Раст здольны выконваць абмежаваны набор аперацый на этапе кампіляцыі, што дазваляе нам выкарыстоуваць зручны спосаб запісу гэтага значэння, такі, які лягчэй зразумець і праверыць, замест таго каб прызначыць гэтай _канстанце_ значэнне `10,800`. Глядзіце [паздзел даведніка па Раст па вылічэнні канстант](https://doc.rust-lang.org/stable/reference/const_eval.html) для больш падрабязнай інфармацыі пра тое, якія аперацыі можна выкарыстоўваць пры аб'яўленні _канстант_.

_Канстанты_ існуюць і дзейнічаюць увесь час пакуль праграма працуе, знаходзяцца яны ў абсягу кода ў якім яны былі аб'яўляны. Гэта ўласцівасць робіць ужыванне канстант зручным  дзе ля  таго каб розныя часткі праграмы маглі даведацца пра спецыяльныя тэхнічные значэнні, такія як максімальная колькасць ачкоў, якую можа набраць любы гулец у гульні, або хуткасць святла.

Ствараць такія нязменныя ды лёгкадаступныя значэнні, якія выкарыстоўваюцца па ўсёй праграме ужываючы `const` зручна так сама дзеля перадачы інфармацыі аб іх усеагульным ужыванні будучым суправаджальнікам кода, само слова `const`  у кодавай базе надае такім значэнням асабісты сэнс. Паколькі запіс `const` звычайна не ўжываецца мноства разоў дзеля аднаго ды таго ж выраза, яна таксама дапамагае мець толькі адно месца ў кодзе, якое трэба змяніць, калі ў будучыні павінна будзе абнавіць такое статычнае значэнне.

## Адцяненне

Як вы бачылі ў падзеле [2.-pabudova-gulni-adgadki.md](../2.-pabudova-gulni-adgadki.md "mention"), магчыма аб’явіць новую _пераменную_ з такім жа імем, як папярэдняя пераменная. Растацарыянцы кажуць, што першая _пераменная_ адцянена другой, маецца на ўвазе, што другая _пераменная_ — гэта тое, што ўбачыць кампілятар, калі вы выкарыстоўваеце яе імя. Фактычна, другая пераменная адцяняе першую, з'яўляючыся актыўнай дзе ля коду, пакуль не будзе адцянена яна, ці пакуль не скончыцца той абсяг у якім яна выкарыстоуваецца. Мы можам адцяніць пераменную, выкарыстоўваючы такое ж імя  ды ўжываючы ключавое слова `let` :

{% code title="Filename: src/main.rs" %}
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("Значэнне x у абсягу ўнутранней вобласці: {x}");
    }

    println!("Значэнне x зараз: {x}");
}
```
{% endcode %}

Гэтая праграма спачатку прывязвае `x` да значэння `5`. Потым яна стварае новую _дынамічную канстанту_  `x`, паўтараючы  `let x =`, бярэ арыгінальнае значэнне і дадае `1`, такім чынам значэнне `x` становіцца раўно `6`. Далей, ва ўнутранай вобласці, створанай з дапамогай фігурных дужак, трэцяя аперацыя `let` таксама адцяняе `x` і стварае новую _дыканстанту_, памнажаючы папярэдняе значэнне на `2` – `x` набывае значэнне `12`. Калі гэтая вобласць зачыняецца дужкай, апошняе адцяненне здымаецца і сінтаксічна `x` вяртаецца да значэння `6`. Трэба казаць што на самой справе мы ўжо звяртаемся да зусім іншай дыканстанце, якая саадносна захавана ў зусім іншым сегменце памяці. Пры запуску гэтай праграмы яна выдасць наступнае:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
Значэнне x у абсягу ўнутранней вобласці: 12
Значэнне x зараз: 6
```

Адцяненне адрозніваецца ад пераўтварэння _дыканстанты_ ў _пераменную_ з дапамогай `mut`, таму што мы атрымліваем памылку кампіляцыі, калі выпадкова спрабуем перазапісаць значэнне _дыканстанты_ без выкарыстання ключавога слова `let`. Выкарыстоўваючы `let`, мы можам зрабіць некалькі трансфармацый значэння, але пасля гэтых трансфармацый _дыканстанта_ застанецца _нязменнай_.

Іншае адрозненне паміж `mut` і _адцяненнем_ заключаецца ў тым, што, калі мы выкарыстоўваем ключавое слова `let` яшчэ раз, мы фактычна ствараем новую _дыканстанту_, такім чынам мы можам змяніць тып значэння, але працягваць выкарыстоўваць тое ж імя. Напрыклад, скажам, наша праграма запытвае карыстальнікаў націснуць на прабел столькі разоў, колькі прабелаў яны хочуць бачыць паміж словамі ў тэксце, а потым мы хочам захаваць гэтую колькасць як лік, а не як радок:

```rust
    let spaces = "   ";
    let spaces = spaces.len();
```

Першы раз `spaces` з'яўляецца радком, а другі раз `spaces` з'яўляецца лічбовым тыпам. Адцяненне дазваляе нам пазбегнуць неабходнасці прыдумляць розныя імёны, такія як `spaces_str` ды `spaces_num`; замест гэтага мы можам выкарыстоўваць больш простае імя `spaces`. Аднак, калі мы замест _адцянення_ паспрабуем выкарыстаць мадзіфікацыю `mut` , а потым перазапісаць наш радок лічбовым значэннем – мы атрымаем памылку кампіляцыі, як паказана ніжэй <img src="../.gitbook/assets/does_not_compile.svg" alt="" data-size="line">:&#x20;

```rust
    let mut spaces = "   ";
    spaces = spaces.len();
```

Памылка абвяшчае, што нам не дазволена змяняць тып пераменнай:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
```

Цяпер, калі мы даследавалі як працуюць _пераменныя_ ды _канстанты_, давайце разгледзім тыпы дадзеных да якіх могуць адносіцца іх значэнні.
